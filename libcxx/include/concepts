// -*- C++ -*-
//===---------------------------- concepts -------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===---------------------------------------------------------------------===//

#ifndef _LIBCPP_CONCEPTS
#define _LIBCPP_CONCEPTS

/*
    concepts synopsis

namespace std {

// [concepts.lang], language-related concepts
// [concept.same], concept same_­as
template<class _Tp, class _Up>
concept same_as;

// [concept.derived], concept derived_­from
template<class Derived, class Base>
concept derived_from;

// [concept.convertible], concept convertible_­to
template<class From, class To>
concept convertible_to;

// [concept.commonref], concept common_­reference_­with
template<class _Tp, class _Up>
concept common_reference_with;

// [concept.common], concept common_­with
template<class _Tp, class _Up>
concept common_with;

// [concepts.arithmetic], arithmetic concepts
template<class _Tp>
concept integral;

template<class _Tp>
concept signed_integral;

template<class _Tp>
concept unsigned_integral;

template<class _Tp>
concept floating_point;

// [concept.assignable], concept assignable_­from
template<class LHS, class RHS>
concept assignable_from;

// [concept.swappable], concept swappable
namespace ranges {
    inline namespace unspecified {
        inline constexpr unspecified swap = unspecified;
    }
}

template<class _Tp>
concept swappable;

template<class _Tp, class _Up>
concept swappable_with;

// [concept.destructible], concept destructible
template<class _Tp>
concept destructible;

// [concept.constructible], concept constructible_­from
template<class _Tp, class... Args>
concept constructible_from;

// [concept.defaultconstructible], concept default_­constructible
template<class _Tp>
concept default_constructible;

// [concept.moveconstructible], concept move_­constructible
template<class _Tp>
concept move_constructible;

// [concept.copyconstructible], concept copy_­constructible
template<class _Tp>
concept copy_constructible;

// [concepts.compare], comparison concepts
// [concept.boolean], concept boolean
template<class B>
concept boolean;

// [concept.equalitycomparable], concept equality_­comparable
template<class _Tp>
concept equality_comparable;

template<class _Tp, class _Up>
concept equality_comparable_with;

// [concept.totallyordered], concept totally_­ordered
template<class _Tp>
concept totally_ordered;

template<class _Tp, class _Up>
concept totally_ordered_with;

// [concepts.object], object concepts
template<class _Tp>
concept movable;

template<class _Tp>
concept copyable;

template<class _Tp>
concept semiregular;

template<class _Tp>
concept regular;

// [concepts.callable], callable concepts
// [concept.invocable], concept invocable
template<class F, class... Args>
concept invocable;

// [concept.regularinvocable], concept regular_­invocable
template<class F, class... Args>
concept regular_invocable;

// [concept.predicate], concept predicate
template<class F, class... Args>
concept predicate;

// [concept.relation], concept relation
template<class R, class _Tp, class _Up>
concept relation;

// [concept.equiv], concept equivalence_­relation
template<class R, class _Tp, class _Up>
concept equivalence_relation;

// [concept.strictweakorder], concept strict_­weak_­order
template<class R, class _Tp, class _Up>
concept strict_weak_order;

} // namespace std

*/

#include <__config>
#include <type_traits>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_STD

#if _LIBCPP_STD_VER > 17
// clang-format off

// [concepts.lang], language-related concepts
// [concept.same], concept same_­as
template <class _Tp, class _Up>
concept _Same_as_impl =
#ifdef __clang__
    __is_same(_Tp, _Up);
#else
    _VSTD::is_same_v<_Tp, _Up>;
#endif

template <class _Tp, class _Up>
concept same_as = _Same_as_impl<_Tp, _Up> && _Same_as_impl<_Up, _Tp>;

// [concept.derived], concept derived_­from
template <class _Dp, class _Bp>
concept derived_from = __is_base_of(_Bp, _Dp)
                    && is_convertible_v<const volatile _Dp*, const volatile _Bp*>;

// [concept.convertible], concept convertible_­to
template <class _From, class _To>
concept convertible_to = is_convertible_v<_From, _To>
                      && requires(_From (&__f)()) {
	                       static_cast<_To>(__f());
                         };

// [concept.commonref], concept common_reference_with
template<typename _Tp, typename _Up>
concept common_reference_with = same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>>
                             && convertible_to<_Tp, common_reference_t<_Tp, _Up>>
                             && convertible_to<_Up, common_reference_t<_Tp, _Up>>;

// [concept.common], concept common_with
template<class _Tp, class _Up>
concept common_with = same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>>
                   && requires {
                        static_cast<common_type_t<_Tp, _Up>>(_VSTD::declval<_Tp>());
                        static_cast<common_type_t<_Tp, _Up>>(_VSTD::declval<_Up>());
                      }
                   && common_reference_with<add_lvalue_reference_t<const _Tp>,
                                            add_lvalue_reference_t<const _Up>>
                   && common_reference_with<add_lvalue_reference_t<common_type_t<_Tp, _Up>>,
                                            common_reference_t<add_lvalue_reference_t<const _Tp>,
                                                               add_lvalue_reference_t<const _Up>>>;

// [concepts.arithmetic], arithmetic concepts
template<class _Tp>
concept integral = is_integral_v<_Tp>;

template<class _Tp>
concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

template<class _Tp>
concept unsigned_integral = integral<_Tp> && !is_signed_v<_Tp>;

template<class _Tp>
concept floating_point = is_floating_point_v<_Tp>;

// [concept.assignable], concept assignable_from
template<class _To, class _From>
concept assignable_from = is_lvalue_reference_v<_To>
                       && common_reference_with<const remove_reference_t<_To>&,
                                                const remove_reference_t<_From>&>
                       && requires(_To __to, _From&& __from) {
                            { __to = static_cast<_From&&>(__from) } -> same_as<_To>;
                          };

// [concept.destructible], concept destructible
template<class _Tp>
concept destructible = is_nothrow_destructible_v<_Tp>;

// clang-format on
#endif // _LIBCPP_STD_VER > 17

_LIBCPP_END_NAMESPACE_STD

#endif // _LIBCPP_CONCEPTS
